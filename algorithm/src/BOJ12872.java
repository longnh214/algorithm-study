/**
 * @author nakhoonchoi
 * @date 2025/07/23
 * @see https://boj.ma/12872
 * @mem 14,336kb
 * @time 100ms
 * @caution
 * [고려사항]
 * MOD 연산이 들어가야해서 DP 문제라는 것을 알 수 있었다.
 * 하지만 dp 배열과 점화식을 어떻게 설계해야할 지 어려웠다.
 * dp[플레이리스트 진행 단계][이전까지 진행 곡 숫자][현재 진행 곡 숫자] 처럼 선언하거나
 * 비트마스킹을 사용해야하나? 싶었는데 N이 100이라서 비트마스킹은 안된다고 생각했다.
 *
 * 다시 생각해보니 곡의 번호와는 전혀 상관없이 새로운 곡을 플리에 추가하는 지, 이미 있는 곡을 플리에 다시 추가하는 지를
 * 고려해서 문제를 풀면 되었다.
 *
 * 💡 N과 P가 같으면서 M이 0인 케이스를 직접 적어보면서 얻은 힌트였다.
 *
 * 예를 들어서 입력이 "1 0 1"이라면 (노래1)로 끝이고,
 * 입력이 "2 0 2"라면 (노래1, 노래2) 혹은 (노래2, 노래1)이다.
 * 하지만 "2 0 3"이 된다면 위의 경우의 수 (노래1, 노래2), (노래2, 노래1)에서 M이 0이기 때문에 어떤 수든 추가해줘도 되었다.
 *
 * 이 규칙(?)을 가지고 점화식을 생각했다.
 *
 * dp 배열은 2차원 배열로 다음과 같이 설정했다. 그리고 모듈러 연산을 하더라도 오버플로우가 발생할 수 있기 때문에 long 자료형으로 선언해야한다.
 * dp[플레이리스트의 현재까지 총 곡 수][플레이리스트에 포함되어있는 곡 수]
 * dp[P+1][N+1]
 *
 * 먼저 초기값으로 플레이리스트에 아무 곡도 없는 경우 dp[0][0]을 1로 설정한다.
 * 2중 반복문으로 i를 1부터 P만큼 순회하면서
 * 안에서 j를 1부터 (N과 i 중에 작은 값)까지 순회한다.
 *
 * dp[i][j]에 값을 넣어줄텐데 MOD 연산을 잘해주어야한다.
 *
 * 먼저 새로운 곡이 들어오는 경우는 앞 플레이리스트 단계에 곡이 현재보다 한 곡 적은 경우의 수를 (N - (j-1)) 만큼 곱해서 더해준다.(MOD 연산)
 * - (N - (j-1))만큼 곱해주는 이유는 이전까지 나오지 않은 곡의 수 만큼 새로 포함될 수 있기 때문에 곱해주었다.
 *
 * 그리고 기존에 있던 곡이 들어오는 경우는 j가 M보다 크다면 앞 플레이리스트 단계에서 기존 곡 까지 있는 경우의 수에 (j-M)을 곱해준 값을 더해주었다.(MOD 연산)
 * 대신에 j가 M보다 큰 경우에만 체크해야한다.
 * - (j-M)만큼 곱해주는 이유는 이미 포함된 노래 중 마지막에 추가된 곡에서 최소 M 곡 이상 떨어진 노래만 추가가 가능하기 때문에 (j-M)곡 만큼만 추가가 가능하다.
 * - 예를 들어서 현재까지 3 7 1 5를 플레이리스트에 추가했었고, M이 2라면, 3번과 7번곡만 추가가 가능하다.
 *   이 경우는 j가 4이고, M이 2인 경우이므로 j-M인 2개의 곡만 추가할 수 있다는 뜻과 같다.
 *
 * DP 문제 중에 특히 골드 상위 문제여서 정말 어려웠다.
 * [입력사항]
 * [출력사항]
 */
import java.io.*;
import java.util.*;
//백준 <DP> '플레이리스트'

public class BOJ12872{
    public static void main(String[] args) throws IOException{
        final int MOD = 1_000_000_007;

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken()); //총 노래 곡 수
        int M = Integer.parseInt(st.nextToken()); //제한 gap
        int P = Integer.parseInt(st.nextToken()); //플레이리스트 곡 수

        long [][] dp = new long[P+1][N+1];

        dp[0][0] = 1;

        for(int i=1;i<=P;i++){
            for(int j=1;j<=Math.min(i, N);j++){
                dp[i][j] += ((dp[i-1][j-1] * (N - (j-1))) % MOD);

                if(j > M){
                    dp[i][j] += ((dp[i-1][j] * (j-M)) % MOD);
                }

                dp[i][j] %= MOD;
            }
        }

        System.out.println(dp[P][N] % MOD);
    }
}